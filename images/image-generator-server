#!/usr/bin/env python3

from flask import Flask, jsonify, request, send_file
import glob
import os
import shutil
import subprocess
import time

app = Flask(__name__)

supported_platforms = ['dragonboard','pc-amd64','pc-i386','pi3','pi2']
supported_channels = ['edge', 'beta', 'candidate', 'stable']
supported_versions = [16, 18]
cache_theshold_minutes = 180


def report_error(message, code):
    error = dict()
    error['message'] = message
    error['status_code'] = code
    return jsonify(error)


def find_image_on_dir(output_dir):
    if not os.path.isdir(output_dir):
        return None, report_error('Output dir does not exist', 410)

    images = glob.glob('{}/*.img'.format(output_dir))
    if len(images) == 1:
        return images[0], None
    else:
        return None, report_error('Image not found in output dir', 410)


def get_image_already_created(output_dir, force):
    # In case force is 1 then the image need to be created again
    if not os.path.isdir(output_dir) or force:
        return None, None

    # In case the image has been created before the cache theshold
    # the image need to be created again
    dir_mod_time = os.stat(output_dir).st_mtime
    elapsed_minutes = (time.time() - dir_mod_time) / 60
    if elapsed_minutes > cache_theshold_minutes:
        return None, None

    # Return the created image just when there is 1 image in the output dir
    return find_image_on_dir(output_dir)

"""
Generate a list of snaps compatible with ubuntu-image
"""
def prepare_snap_list(snaps):
    if snaps:        
        return sorted(snaps.replace('|', '=').replace(',', ' ').split(' '))
    return []


"""
Define the output dir for the image based on the input arguments
"""
def get_output_dir(channel, version, snap_list, platform):
    output_dir = os.path.join('output', '{}-{}-{}'.format(platform, version, channel))
    for snap in snap_list:
        output_dir = '{}-{}'.format(output_dir, snap.replace('=', '_'))
    print('Output dir used: {}'.format(output_dir))
    return output_dir


def get_image_options(platform):
    if platform.startswith('pc'):
        return '--image-size 3G'
    return ''


def get_snap_options(snap_list):
    snaps_option = ''
    for snap in snap_list:
        snaps_option = '{} --snap {}'.format(snaps_option, snap)
    return snaps_option



"""
Create an image and resurn the image information and path
"""
def create_image(channel, version, snaps, platform, force):

    snap_list = prepare_snap_list(snaps)
    output_dir = get_output_dir(channel, version, snap_list, platform)
    output_dict = {'channel': channel, 'version': version, 'snaps': snap_list, 'platform': platform}

    # In case the image can be reused, then retrieve the path
    image_path, err = get_image_already_created(output_dir, force)
    if err:
        return jsonify(err)
    elif image_path:
        output_dict['path'] = image_path
        output_dict['cached'] = True
        return jsonify(output_dict)

    # Clean the output dir
    if os.path.isdir(output_dir):
        shutil.rmtree(output_dir)
        os.mkdir(output_dir)

    # Create the image using ubuntu-image tool
    image_option = get_image_options(platform)
    snaps_option = get_snap_options(snap_list)
    line = "ubuntu-image {} {} -c {} -O {} ./models/{}-{}.model".format(image_option, snaps_option, channel, output_dir, platform, version)
    print('Running command line: {}'.format(line))
    res = subprocess.call(line, shell=True)
    if res == 1:
        return report_error('Error running ubuntu-image. Please check the parameters used and try again.', 410)
    
    image_path, err = find_image_on_dir(output_dir)
    if err:
        return jsonify(err)
    else:
        output_dict['path'] = image_path
        output_dict['cached'] = False
        return jsonify(output_dict)


"""
Check the input arguments used to create the image are supported
"""
def check_creation_args(channel, version, platform):
    if not channel in supported_channels:
        report_error(
        'channel: {} not supported. Supported channels: {}'.format(channel, supported_channels),
        410)

    if not version in supported_versions:
        report_error(
        'version: {} not supported. Supported versions: {}'.format(channel, supported_versions),
        410)

    if not platform in supported_platforms:
        report_error(
        'platform: {} not supported. Supported platforms: {}'.format(platform, supported_platforms),
        410)    


@app.route('/')
def hello():
    return "Wellcome to the ubuntu core images generator service!"


# example: http://<ip>:<port>/create?channel=candidate&version=16&snaps=core|beta,rsync|stable&platform=pi2
@app.route('/create', methods=['GET'])
def create():
    query_parameters = request.args
    channel = request.args.get('channel', default = 'beta', type = str)
    version = request.args.get('version', default = 16, type = int)
    snaps = request.args.get('snaps', default = '', type = str)
    platform = request.args.get('platform', default = 'dragonboard', type = str)
    force = request.args.get('force', default = False, type = bool)

    error = check_creation_args(channel, version, platform)
    if error:
        return error

    return create_image(channel, version, snaps, platform, force)


# example: http://<ip>:<port>/output/pi2-16-beta/pi2.img
@app.route('/output/<path:url>')
def get_image(url):
    return send_file(os.path.join('output', url))


if __name__ == "__main__":
    app.run(host='0.0.0.0', port=80)
